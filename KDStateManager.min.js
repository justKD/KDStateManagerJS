/**
 * @file kdstatemanager.min.js
 * @author justKD
 * @copyright justKD 2019
 * @license MIT https://notnatural.co/license/
 */

/**
 * Parameter object for the `KDStateManager` constructor.
 * @typedef {object} KDStateManager~Params
 * @property {boolean=} dev - Indicated whether dev mode logging is activated.
 * @property {array=} store - Instantiate the instance with a pre-existing `store`.
 * @property {number=} currentIndex - Instantiate the instance with a predetermined `currentIndex`.
 */

/**
 *  Instantiates a `new KDStateManager()`.
 * 
 *  @param {object=} template - Object containing keyed functions. Keys should match the keys for any state objects 
 *                              that will be stored, and the values should be functions handling the state values.
 *  @param {KDStateManager~Params=} params - Optional parameters `dev`, `store`, and `currentIndex`.
 * 
 *  @notes Class representing a manager for storing and recalling JSON objects representing state values.
 *         The template is an object of keyed functions that should operate on an expected value/type.
 *         A state is an object of keys (and any values) that correspond with templated keys.
 *         When a state is recalled, if any keys in the recalled state match keys in the template, the state value will be passed to
 *         the templated function. Store by inserting or appending a state, recall or delete a state by index, infinite undo/redo.
 *  
 *  @public
 *      devMode()
 *      onError()
 *      index
 *          .set()
 *          .current()
 *          .first()
 *          .last()
 *      template()
 *      store()
 *      localStorage
 *          .set()
 *          .get()
 *      append()
 *      recall()
 *      delete()
 *      insert()
 *      replace()
 *      undo()
 *      redo()
 * 
 * @example
 * 
 *      const state = {
 *          level: 34,
 *          class: 'warrior',
 *          stats: [5, 5, 5, 5],
 *          equip: {
 *              hands: gloves,
 *              head: hat,
 *          },
 *      }
 * 
 *      const state2 = {
 *          level: 50,
 *          class: 'warrior',
 *          stats: [10, 10, 10, 10],
 *          equip: {
 *              hands: betterGloves,
 *              head: biggerHat,
 *          },
 *      }
 * 
 *      const stateManager = new KDStateManager({
 *          level: value => handleLevel(value),
 *          class: value => setClass(value),
 *          stats: value => stats.forEach(stat => handleStat(stat)),
 *          equip: value => {
 *              equip(value.hands)
 *              equip(value.hat)
 *          },
 *      }, {
 *          dev: true
 *      })
 * 
 *      stateManager.append(state)
 *      stateManager.append(state2)
 *      console.log( s == state )
 *      stateManager.undo(s => console.log( s == state ))
 *      stateManager.redo(s => console.log( s == state2 ))
 *      stateManager.recall(0, s => console.log( s == state ))
 *      
 */

class KDStateManager{constructor(t,r){const o={mode:!!r.dev&&r.dev,props:{onError:e=>console.log("%c "+e+" ",o.console.text(o.props.colors.error)),colors:{error:"#F1828D",log:"#FEFAD4",start:"#8FB9A8"}},console:{text:e=>"color:"+e+";",background:e=>"background:"+e+";"},start:(e,t,r)=>{o.mode&&(e="string"==typeof e?e:" ",console.groupCollapsed("%c"+e,o.console.text(o.props.colors.start)+"font-weight: normal;"),null!=t&&console.log(t),r&&console.trace())},end:(e,t,r,n)=>{o.mode&&(e?"function"==typeof t&&t():"function"==typeof r&&r(),n&&console.trace(),console.groupEnd(),e||console.log("%c^ Failed ",o.console.background(o.props.colors.error)+o.console.text("#000")))},log:(e,t,r)=>{if(o.mode){let n=null;e&&(n="%c"+(e="string"==typeof e?e:" "),o.console.text(o.props.colors.log)),console.group("%c"+e,o.console.text(o.props.colors.log)+"font-weight: normal;"),console.log(t),r&&console.trace(),console.groupEnd()}},error:(t,r)=>{"function"==typeof(r=r||o.props.onError)?r(new Error(t)):console.log("%c "+e+" ",o.console.color(o.props.colors.error)),console.trace()}};this.devMode=(e=>o.mode=e),this.onError=(e=>o.props.onError=e);const n=e=>JSON.parse(JSON.stringify(e)),l=(e,t)=>"function"==typeof e?e(t):o.log("handleCB","no valid callback"),s=e=>{let t=!0;return"object"==typeof e?Object.values(e).forEach(e=>{"function"!=typeof e&&(t=!1)}):t=!1,t},c={template:s(t)?t:{},store:Array.isArray(r.store)?r.store:[],currentIndex:null!=r.currentIndex&&r.currentIndex>-1?r.currentIndex:-1},a={template:(e,t)=>{let r=!1;const o=n(e);return s(o)&&(c.template=o,r=o),l(t,r),r},store:(e,t)=>{let r=!1;const o=n(e);return Array.isArray(o)&&(c.store=o,c.currentIndex=this.index.last(),r=o),l(t,r),r},localStorage:{set:(e,t)=>(localStorage.setItem(e,JSON.stringify(n(c))),l(t,!0),!0),get:(e,t)=>{let r=localStorage.getItem(e);return r&&(r=JSON.parse(r),c=n(r)),l(t,r),r}},append:(e,t)=>{const r=n(e);return c.store.push(r),c.currentIndex=c.store.length-1,l(t,r),r},recall:(e,t)=>{let r=!1;return c.store[e]&&(c.currentIndex=e,r=n(c.store[e]),Object.keys(c.template).forEach(e=>{c.template[e]&&c.template[e](r[e])})),l(t,r),r},delete:(e,t)=>{let r=!1;return c.store[e]&&(r=n(c.store[e]),c.store.splice(e,1),c.currentIndex--),l(t,r),r},insert:(e,t,r)=>{let o=!1;const s=n(t);return c.store[e]||e==c.store.length?(c.store.splice(e,0,s),e<c.currentIndex&&c.currentIndex++,o=s):e>-1&&(c.store.push(s),c.currentIndex=c.store.length,o=s),l(r,o),o},replace:(e,t,r)=>{if(a.delete(e,e=>{}))return a.insert(e,t,r)},undo:e=>c.currentIndex>0&&a.recall(c.currentIndex-1,e),redo:e=>c.currentIndex<this.index.last()&&a.recall(c.currentIndex+1,e)};this.index={set:e=>c.store[e]?c.currentIndex=e:o.error("Unable to set current index.\n Invalid index ("+e+")."),current:e=>n(c.currentIndex),last:e=>c.store.length-1,first:e=>0},this.template=((e,t)=>{if(e){o.start("set template:",e);const r=a.template(e,t);o.end(r,null,e=>o.error("Unable to set template."))}return n(c.template)}),this.store=((e,t)=>{if(e){o.start("set store: ",e);const r=a.store(e,t);o.end(r,null,e=>o.error("Unable to set store.\n Must be an Array."))}return n(c.store)}),this.localStorage={set:(e,t)=>{o.start("localStorage SET: ",e);const r=a.localStorage.set(e,t);o.end(r,null,e=>o.error("Unable to save to localStorage."))},get:(e,t)=>{o.start("localStorage GET: ",e);const r=a.localStorage.get(e,t);o.end(r,null,e=>o.error("Unable to retrieve from localStorage."))}},this.append=((e,t)=>{o.start("append:",e);const r=a.append(e,t);return o.end(r),r}),this.recall=((e,t)=>{o.start("recall index: "+e);const r=a.recall(e,t);return o.end(r,null,t=>o.error("Unable to recall.\n Invalid index ("+e+").")),r}),this.delete=((e,t)=>{o.start("delete index: "+e);const r=a.delete(e,t);o.end(r,null,t=>o.error("Unable to delete.\n Invalid index ("+e+")."))}),this.insert=((e,t,r)=>{o.start("insert at index: "+e);const n=a.insert(e,t,r);o.end(n,null,t=>o.error("Unable to insert at index "+e+".\n Invalid index ("+e+")."))}),this.replace=((e,t,r)=>{o.start("replace state at index: "+e);const n=a.replace(e,t,r);o.end(n,null,t=>o.error("Unable to replace at index "+e+".\n Invalid index ("+e+")."))}),this.undo=(e=>{o.start("undo to index: "+(this.index.current()-1)+" out of "+this.index.last());const t=a.undo(e);o.end(t,null,e=>o.error("Unable to undo.\n Invalid index ("+(c.currentIndex-1)+")."))}),this.redo=(e=>{o.start("redo to index: "+(this.index.current()+1)+" out of "+this.index.last());const t=a.redo(e);o.end(t,null,e=>o.error("Unable to redo.\n Invalid index ("+(c.currentIndex+1)+")."))})}}